# var let const 的区别

> 编译阶段都会进行变量提升，

`var`、`let` 和 `const` 是 JavaScript 中声明变量的三种方式。`var` 是 ES5 及之前唯一的声明方式，而 `let` 和 `const` 是在 ES6（ES2015）中引入的。

根据您提供的来源，它们的主要区别可以归纳为以下四个方面：**作用域**、**变量提升与暂时性死区**、**重复声明**以及**赋值与初始化**。

### 1. 作用域 (Scope)

这是最显著的区别之一。

- **`var` (函数作用域):** `var` 声明的变量的作用域是它当前的执行上下文。如果在函数内声明，它在整个函数内有效；如果在函数外声明，则是全局变量,。它不存在“块级作用域”的概念，这意味着在 `if` 或 `for` 循环的代码块 `{}` 中声明的 `var` 变量会“泄露”到外部,。
- **`let` 和 `const` (块级作用域):** 这两者声明的变量仅在它们所在的代码块（Block）内有效（例如 `{}` 内部）,。
  - **循环中的特殊表现：** 在 `for` 循环中，使用 `var` 声明计数器变量（如 `i`）会导致该变量泄露为全局变量，且所有循环迭代共享同一个 `i`。而使用 `let` 声明循环变量时，每一次循环迭代都会创建一个新的变量 `i`，JavaScript 引擎会记住上一轮的值并在其基础上计算，这完美解决了闭包和循环计数器的问题。

### 2. 变量提升与暂时性死区 (Hoisting & TDZ)

所有声明在某种程度上都会被“提升”，但处理方式完全不同。

- **`var` (变量提升):** `var` 声明的变量会在代码执行前被“提升”到作用域顶部，并自动初始化为 `undefined`。这意味着你可以在声明语句之前使用该变量，不会报错，只会得到 `undefined`,,。
- **`let` 和 `const` (暂时性死区):** 虽然它们在词法环境实例化时也被创建了，但在定义语句执行之前，它们**不会被初始化**。
  - 从代码块开始到变量声明语句完成之前的这段区域，被称为**“暂时性死区” (Temporal Dead Zone, TDZ)**。
  - 如果在 TDZ 内访问该变量，JavaScript 会抛出 `ReferenceError` 错误,。这也意味着 `typeof` 不再是百分之百安全的操作，在 TDZ 中对 `let` 变量使用 `typeof` 也会报错。

### 3. 重复声明 (Redeclaration)

- **`var`:** 允许在同一作用域内重复声明同一个变量，后声明的会覆盖先声明的,。
- **`let` 和 `const`:** 不允许在相同作用域内重复声明同一个变量。如果尝试这样做，会抛出语法错误（SyntaxError）,。

### 4. 赋值与常量特性 (Assignment & Const)

- **`var` 和 `let`:** 声明的是变量，可以没有初始值（默认为 `undefined`），并且可以随时重新赋值,。
- **`const`:** 声明的是只读常量。
  - **必须初始化：** 声明时必须立即赋值，不能留到以后赋值，否则报错。
  - **不可重新赋值：** 一旦声明，不能通过赋值语句改变其值,。
  - **本质（重要）：** `const` 保证的不是变量的值不得改动，而是变量指向的**内存地址**不得改动。
    - 对于基本数据类型（如数字、字符串），值保存在栈内存中，等同于常量。
    - 对于引用类型（如对象、数组），变量保存的是指向堆内存的指针。`const` 只能保证指针不变，但**对象本身的属性是可以修改的**（例如可以给数组 `push` 新元素，或修改对象的属性）,。如果需要彻底冻结对象，需要使用 `Object.freeze()`。

### 5. 顶层对象属性 (Global Object Properties)

这是一个较少被提及但在全局环境下很重要的区别。

- **`var`:** 在全局作用域中使用 `var` 声明的变量，会成为顶层对象（在浏览器中是 `window`）的属性,。例如 `var a = 1`，则 `window.a` 也是 1。
- **`let` 和 `const`:** 在全局作用域中声明的变量，**不会**成为顶层对象的属性,。它们保存在一个独立的 Script 作用域中，而不是挂载在 Global 对象上。

### 总结与最佳实践

| 特性         | var                      | let                      | const                    |
| ------------ | ------------------------ | ------------------------ | ------------------------ |
| **作用域**   | 函数作用域               | 块级作用域               | 块级作用域               |
| **变量提升** | 提升，初始化为 undefined | 存在死区 (TDZ)，访问报错 | 存在死区 (TDZ)，访问报错 |
| **重复声明** | 允许                     | 不允许                   | 不允许                   |
| **重新赋值** | 允许                     | 允许                     | 不允许 (只读引用)        |
| **全局属性** | 挂载到 window            | 不挂载                   | 不挂载                   |

**何时使用？** 业界目前的普遍观点是：

1. **优先使用 `const`：** 这有助于防止意外修改变量，且让代码意图更清晰（表示该变量不应被重新赋值）。
2. **需要重新赋值时使用 `let`：** 例如循环计数器或状态标识。
3. **尽量避免使用 `var`：** 除非你需要兼容非常古老的浏览器或维护旧代码，否则 ES6 环境下应避免使用 `var`，以减少因变量提升和作用域问题导致的 bug,。



# 作业

## 严格模式

根据您提供的来源，**严格模式 (Strict Mode)** 是一种 JavaScript 的运行模式，它通过改变语言的语法和行为，将一些潜在的错误转变为直接抛出异常，从而让代码更加严谨和安全。

在您提供的资料中，关于严格模式的主要特点和行为如下：

### 1. `this` 的指向发生变化

在严格模式下，函数内的 `this` 绑定机制有所不同。

- **普通函数调用：** 在非严格模式下，如果函数并非作为对象的方法调用，`this` 会指向顶层对象（浏览器中为 `window`）。但在严格模式下，`this` 会返回 `undefined`。
- **获取顶层对象：** 由于严格模式下 `this` 不再指向全局对象，这使得在不同环境（如 Node.js 和浏览器）中统一获取顶层对象变得更加困难。

### 2. 普通模式下“静默失败”的操作抛出错误

严格模式会让一些在普通模式下“静默失败”的操作抛出错误。

- **冻结对象：** 当使用 `Object.freeze()` 冻结一个对象后，如果尝试修改其属性：
  - 在**普通模式**下，该操作可能不起作用但不会报错。
  - 在**严格模式**下，该行代码会直接报错（TypeError）。

### 3. 变量名与标识符的限制

严格模式对标识符的使用有更严格的限制，防止语法混淆。

- **保留字：** 在严格模式下，`let` 被视为保留字/标识符，不能用作变量名或函数名（例如 `var let = 1` 会报错）。而在非严格模式下，为了兼容旧代码，`let` 可能被允许作为标识符使用。
- **受保护的关键字：** 严格模式下，不能定义名为 `arguments` 或 `eval` 的变量，也不能给它们赋值。

### 4. 函数声明的限制

- **块级作用域中的函数：** 在严格模式下，函数只能声明在当前作用域的顶层。例如，在 `if` 语句中，如果没有使用大括号 `{}` 包裹（即没有形成块级作用域），直接声明函数（如 `if (true) function f() {}`）会报错。
- **参数限制：** 在使用非简单参数（如默认参数、解构赋值、剩余参数）的函数中，不允许在函数体内显式声明 `"use strict"`，否则会导致语法错误。

### 5. 其他语法限制

- **八进制字面量：** 严格模式下，禁止使用前缀为 `0` 的八进制字面量（例如 `0123`），这被视为语法错误。
- **重复参数：** 虽然文中未详细展开，但来源中列出的语法错误列表包含“重复的形式参数 (duplicate formal argument)”，这通常也是严格模式下的限制之一。

### 总结

严格模式主要用于消除 JavaScript 语法中的一些不合理或不严谨之处（如静默失败的赋值、模糊的 `this` 指向），并为未来的语言特性（如保留字 `let`）做铺垫。在涉及到 `class`（类）和 `module`（模块）时，JavaScript 默认就是以严格模式运行的。



## Node 环境和浏览器环境的区别

Node.js 的 `global` 与浏览器的 `window` 主要有以下核心差异：

1. **顶级作用域不同（顶层对象不同）** 浏览器的顶级作用域就是全局作用域。而在 Node.js 中，文件顶层属于**模块作用域**（Module Scope），代码实际上是封装在一个包装函数内部执行的。
2. **变量挂载行为不同**

  	**浏览器**：在顶级作用域使用 `var` 定义变量，它会自动成为 `window` 对象的属性，可以通过 `this` 访问。
  	
  	**Node.js**：在顶级作用域定义的变量仅存在于当前模块中，**不会**自动成为 `global` 对象的属性，因此无法通过 `this` 或 `global` 访问到该变量。

3. **API 生态不同**

​	**浏览器**：核心是与 `document`、DOM

​	**Node.js** ：的 API 生态主要是为了**服务端开发**设计的，它提供了大量底层操作系统访问能力。

尝试在两边的控制台运行这段代码：

JavaScript

```
console.log(typeof window);
console.log(typeof process);
```

- 在**浏览器**里，你会得到 `object` 和 `undefined`。
- 在**Node.js**里，你会得到 `undefined` 和 `object`。
