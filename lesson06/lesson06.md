> **闭包是基石**：无论是柯里化还是偏函数，本质上都是利用闭包来“记住”那些被预先填入的参数。

## 函数柯里化 Currying

- ES6 箭头函数版 `const addFn = (a) => (b) => (c) => a + b + c` 调用 `addFn(1)(2)(3)`

- 标准函数版

  ~~~js
  function add(a) {
    return function (b) {
      return function (c) {
        return a + b + c;
      };
    };
  }
  add(1)(2)(3)
  ~~~

  执行顺序

  | **步骤**   | **调用方式** | **发生了什么**                                               | **返回值**                          |
  | ---------- | ------------ | ------------------------------------------------------------ | ----------------------------------- |
  | **第一步** | `addFn(1)`   | 传入参数 `a`，在内存中形成一个**闭包**，记录下 `a = 1`。     | 返回一个接收参数 `b` 的**新函数**。 |
  | **第二步** | `(2)`        | 调用第一步返回的函数，传入参数 `b`。此时闭包更新，记录下 `a = 1, b = 2`。 | 返回一个接收参数 `c` 的**新函数**。 |
  | **第三步** | `(3)`        | 调用第二步返回的函数，传入参数 `c`。此时闭包内有 `a=1, b=2, c=3`。 | 执行加法运算，返回最终结果 **6**。  |

  每层函数被调用时，它都会“记住”上一层传进来的变量。

  直到最后一层函数执行时，它向上查找作用域链（Scope Chain），找到之前暂存的 `a` 和 `b`，并结合当前的 `c` 完成最终计算。



## 偏函数

核心作用是：**先“预存”一部分参数，生成一个新函数，等到以后再传入剩余的参数。**

~~~js
//偏函数 partialFunction
const partialFun =
  (fn, ...preset) =>
  (...rest) =>
    fn(...preset, ...rest);
~~~

1. **第一阶段（预设）**：当你调用 `partialFun(fn, ...preset)` 时，它并**没有**执行 `fn`。它只是利用**闭包**把 `fn` 和 `preset` 参数存在了内存里，然后返回了一个**新的匿名函数**。
2. **第二阶段（执行）**：当你调用这个返回的匿名函数并传入 `...rest` 时，它才会真正触发 `fn(...preset, ...rest)`，通过展开运算符将两次收集到的参数“拼接”在一起送给原函数。

### 示例：

假设我们有一个通用的加法函数，但我们经常需要执行“加 10”的操作。

~~~js
// 1. 定义一个通用的多参数函数
const sum = (a, b, c) => a + b + c;

// 2. 使用 partialFun 创建一个“预设了参数”的新函数
// 这里的 fn 是 sum，preset 是 10
const addTen = partialFun(sum, 10);

// 3. 调用新函数，传入剩余的参数 (rest)
const result = addTen(5, 2); // 相当于执行 sum(10, 5, 2)

console.log(result); // 输出: 17
~~~

### 实际开发场景：日志打印

在开发中，偏函数常用于固定一些重复的配置项。比如，我们想为不同的模块生成特定的日志函数：

JavaScript

```js
const logger = (level, module, message) => {
  console.log(`[${level}] [${module}]: ${message}`);
};

// 预设“级别”和“模块名”
const userModuleError = partialFun(logger, 'ERROR', 'UserModule');

// 之后只需要关注具体的错误信息
userModuleError('登录超时'); // 输出: [ERROR] [UserModule]: 登录超时
userModuleError('密码错误'); // 输出: [ERROR] [UserModule]: 密码错误
```